## 2. 文件寄存器 Server 端

### 2.1. 功能概述
Server 端需要模拟 Modbus 从站，处理 Client 端的文件读写请求。

### 2.2. 标准文件记录操作（20/21功能码）Server 端

#### 2.2.1. 功能码 20（读文件记录）处理

##### 2.2.1.1. 数据结构设计
```go
// FileStore 文件存储管理器
type FileStore struct {
    files map[uint16]*FileRecord  // 文件号 -> 文件记录
    mu    sync.RWMutex
}

// FileRecord 文件记录
type FileRecord struct {
    FileNumber   uint16              // 文件号
    Records      map[uint16][]byte   // 记录号 -> 记录数据
    TotalRecords uint16              // 总记录数（最大 10000）
    Description  string
}
```

##### 2.2.1.2. 处理流程
```
步骤 1：解析请求
   ├─ 提取功能码（0x14）
   ├─ 提取字节数
   └─ 提取子请求（参考类型、文件号、记录号、记录长度）

步骤 2：验证请求
   ├─ 参考类型必须为 6
   ├─ 文件号存在检查（0x0000-0xFFFF）
   ├─ 记录号范围检查（0x0000-0x270F，即 0-9999）
   └─ 记录长度合理性检查

步骤 3：读取数据
   ├─ 根据文件号查找文件
   ├─ 根据记录号和长度读取数据
   └─ 可能需要跨多个记录读取

步骤 4：构建响应
   ├─ 功能码：0x14
   ├─ 响应数据长度
   ├─ 子响应长度
   ├─ 参考类型：6
   └─ 记录数据

步骤 5：发送响应
   └─ 返回完整 PDU
```

##### 2.2.1.3. 代码示例
```go
func (s *FileStore) HandleReadFileRecord(request []byte) ([]byte, error) {
    // 1. 解析请求
    if len(request) < 8 {
        return s.buildErrorResponse(0x94, 0x03) // 非法数据值
    }
    
    functionCode := request[0]  // 0x14
    byteCount := request[1]
    refType := request[2]       // 必须为 6
    fileNumber := binary.BigEndian.Uint16(request[3:5])
    recordNumber := binary.BigEndian.Uint16(request[5:7])
    recordLength := binary.BigEndian.Uint16(request[7:9])
    
    // 2. 验证请求
    if refType != 6 {
        return s.buildErrorResponse(0x94, 0x03) // 非法数据值
    }
    
    if recordNumber > 9999 {
        return s.buildErrorResponse(0x94, 0x02) // 非法数据地址
    }
    
    // 3. 读取数据
    s.mu.RLock()
    file, exists := s.files[fileNumber]
    s.mu.RUnlock()
    
    if !exists {
        return s.buildErrorResponse(0x94, 0x02) // 非法数据地址
    }
    
    // 读取指定记录的数据
    recordData, err := file.ReadRecords(recordNumber, recordLength)
    if err != nil {
        return s.buildErrorResponse(0x94, 0x02)
    }
    
    // 4. 构建响应
    response := []byte{
        0x14,                           // 功能码
        byte(3 + len(recordData)),      // 响应数据长度
        byte(1 + len(recordData)),      // 子响应长度
        6,                              // 参考类型
    }
    response = append(response, recordData...)
    
    return response, nil
}

// ReadRecords 读取连续记录的数据
func (f *FileRecord) ReadRecords(startRecord, length uint16) ([]byte, error) {
    var data []byte
    
    for i := uint16(0); i < length; i++ {
        recordNum := startRecord + i
        if recordNum >= f.TotalRecords {
            return nil, fmt.Errorf("记录号超出范围")
        }
        
        recordData, exists := f.Records[recordNum]
        if !exists {
            // 未初始化的记录返回 0
            recordData = make([]byte, 2)
        }
        
        data = append(data, recordData...)
    }
    
    return data, nil
}

// buildErrorResponse 构建错误响应
func (s *FileStore) buildErrorResponse(errorCode byte, exceptionCode byte) ([]byte, error) {
    return []byte{errorCode, exceptionCode}, nil
}
```

#### 2.2.2. 功能码 21（写文件记录）处理

##### 2.2.2.1. 处理流程
```
步骤 1：解析请求
   └─ 同功能码 20，额外提取记录数据

步骤 2：验证请求
   └─ 同功能码 20

步骤 3：写入数据
   ├─ 根据文件号查找或创建文件
   ├─ 根据记录号和长度写入数据
   └─ 可能需要跨多个记录写入

步骤 4：构建响应
   └─ 正常响应：回显请求数据

步骤 5：发送响应
   └─ 返回完整 PDU
```

##### 2.2.2.2. 代码示例
```go
func (s *FileStore) HandleWriteFileRecord(request []byte) ([]byte, error) {
    // 1. 解析请求
    if len(request) < 10 {
        return s.buildErrorResponse(0x95, 0x03)
    }
    
    functionCode := request[0]  // 0x15
    byteCount := request[1]
    refType := request[2]
    fileNumber := binary.BigEndian.Uint16(request[3:5])
    recordNumber := binary.BigEndian.Uint16(request[5:7])
    recordLength := binary.BigEndian.Uint16(request[7:9])
    recordData := request[9:]
    
    // 2. 验证请求
    if refType != 6 {
        return s.buildErrorResponse(0x95, 0x03)
    }
    
    if recordNumber > 9999 {
        return s.buildErrorResponse(0x95, 0x02)
    }
    
    if len(recordData) != int(recordLength)*2 {
        return s.buildErrorResponse(0x95, 0x03)
    }
    
    // 3. 写入数据
    s.mu.Lock()
    file, exists := s.files[fileNumber]
    if !exists {
        // 自动创建文件
        file = &FileRecord{
            FileNumber:   fileNumber,
            Records:      make(map[uint16][]byte),
            TotalRecords: 10000,
        }
        s.files[fileNumber] = file
    }
    s.mu.Unlock()
    
    err := file.WriteRecords(recordNumber, recordData)
    if err != nil {
        return s.buildErrorResponse(0x95, 0x04) // 从站设备故障
    }
    
    // 4. 正常响应：回显请求
    return request, nil
}

// WriteRecords 写入连续记录的数据
func (f *FileRecord) WriteRecords(startRecord uint16, data []byte) error {
    recordLength := len(data) / 2  // 字节数转字数
    
    for i := 0; i < recordLength; i++ {
        recordNum := startRecord + uint16(i)
        if recordNum >= f.TotalRecords {
            return fmt.Errorf("记录号超出范围")
        }
        
        // 每个记录存储 2 字节
        recordData := data[i*2 : (i+1)*2]
        f.Records[recordNum] = recordData
    }
    
    return nil
}
```

---

### 2.3. 自定义文件操作（203/204功能码）Server 端

#### 2.3.1. 功能码 203（读文件）处理

##### 2.3.1.1. 数据结构设计
```go
// FileAddressStore 基于地址的文件存储
type FileAddressStore struct {
    data map[uint16][]byte  // 地址 -> 寄存器数据（每个2字节）
    mu   sync.RWMutex
}
```

##### 2.3.1.2. 处理流程
```
步骤 1：将功能码 203 映射到功能码 3
   └─ 功能码 203 = 功能码 3（读保持寄存器）+ 文件语义

步骤 2：处理读取请求
   ├─ 提取起始地址和数量
   ├─ 从内存读取连续寄存器数据
   └─ 返回数据

步骤 3：构建响应
   ├─ 功能码：203
   ├─ 字节数
   └─ 寄存器数据
```

##### 2.3.1.3. 代码示例
```go
func (s *FileAddressStore) HandleReadFile(request []byte) ([]byte, error) {
    // 1. 解析请求
    if len(request) < 5 {
        return s.buildErrorResponse(0xCB, 0x03)
    }
    
    functionCode := request[0]  // 203 (0xCB)
    startAddress := binary.BigEndian.Uint16(request[1:3])
    quantity := binary.BigEndian.Uint16(request[3:5])
    
    // 2. 验证请求
    if quantity == 0 || quantity > 125 {
        return s.buildErrorResponse(0xCB, 0x03) // 非法数据值
    }
    
    // 3. 读取数据
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    var data []byte
    for i := uint16(0); i < quantity; i++ {
        addr := startAddress + i
        regData, exists := s.data[addr]
        if !exists {
            regData = []byte{0, 0} // 未初始化返回 0
        }
        data = append(data, regData...)
    }
    
    // 4. 构建响应
    response := []byte{
        0xCB,              // 功能码 203
        byte(len(data)),   // 字节数
    }
    response = append(response, data...)
    
    return response, nil
}
```

#### 2.3.2. 功能码 204（写文件）处理

##### 2.3.2.1. 处理流程
```
步骤 1：将功能码 204 映射到功能码 16
   └─ 功能码 204 = 功能码 16（写多个寄存器）+ 文件语义

步骤 2：处理写入请求
   ├─ 提取起始地址、数量和数据
   ├─ 写入连续寄存器数据
   └─ 返回响应

步骤 3：构建响应
   ├─ 功能码：204
   ├─ 起始地址
   └─ 写入数量
```

##### 2.3.2.2. 代码示例
```go
func (s *FileAddressStore) HandleWriteFile(request []byte) ([]byte, error) {
    // 1. 解析请求
    if len(request) < 7 {
        return s.buildErrorResponse(0xCC, 0x03)
    }
    
    functionCode := request[0]  // 204 (0xCC)
    startAddress := binary.BigEndian.Uint16(request[1:3])
    quantity := binary.BigEndian.Uint16(request[3:5])
    byteCount := request[5]
    data := request[6:]
    
    // 2. 验证请求
    if quantity == 0 || quantity > 123 {
        return s.buildErrorResponse(0xCC, 0x03)
    }
    
    if int(byteCount) != len(data) || byteCount != byte(quantity*2) {
        return s.buildErrorResponse(0xCC, 0x03)
    }
    
    // 3. 写入数据
    s.mu.Lock()
    defer s.mu.Unlock()
    
    for i := uint16(0); i < quantity; i++ {
        addr := startAddress + i
        regData := data[i*2 : (i+1)*2]
        s.data[addr] = regData
    }
    
    // 4. 构建响应
    response := make([]byte, 5)
    response[0] = 0xCC  // 功能码 204
    binary.BigEndian.PutUint16(response[1:3], startAddress)
    binary.BigEndian.PutUint16(response[3:5], quantity)
    
    return response, nil
}
```

---

### 2.4. Server 端完整实现架构

#### 2.4.1. 主要组件
```
┌─────────────────────────────────────┐
│      Modbus Server Main Loop        │
├─────────────────────────────────────┤
│  - 监听 TCP/RTU 连接                │
│  - 接收请求                         │
│  - 路由到对应处理器                 │
│  - 返回响应                         │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│       Function Code Router          │
├─────────────────────────────────────┤
│  0x14 → ReadFileRecordHandler       │
│  0x15 → WriteFileRecordHandler      │
│  0xCB → ReadFileHandler             │
│  0xCC → WriteFileHandler            │
│  其他  → StandardHandlers           │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│         Storage Layer               │
├─────────────────────────────────────┤
│  - FileStore (标准文件记录)         │
│  - FileAddressStore (地址方式)      │
│  - 数据持久化（可选）               │
└─────────────────────────────────────┘
```

#### 2.4.2. 初始化示例
```go
func main() {
    // 1. 创建存储管理器
    fileStore := NewFileStore()
    addressStore := NewFileAddressStore()
    
    // 2. 初始化测试文件
    fileStore.CreateFile(1, "Temp", 256)        // 文件号1，256字节
    fileStore.CreateFile(2, "Status", 128)      // 文件号2，128字节
    
    // 3. 创建 Modbus Server
    server := modbus.NewTCPServer(":502")
    
    // 4. 注册处理器
    server.RegisterHandler(0x14, fileStore.HandleReadFileRecord)
    server.RegisterHandler(0x15, fileStore.HandleWriteFileRecord)
    server.RegisterHandler(0xCB, addressStore.HandleReadFile)
    server.RegisterHandler(0xCC, addressStore.HandleWriteFile)
    
    // 5. 启动服务
    log.Println("Modbus 文件服务器启动: :502")
    if err := server.ListenAndServe(); err != nil {
        log.Fatal(err)
    }
}
```

---

## 3. 配置示例

### 3.1. Client 端配置（功能码 20）

```yaml
# EdgeX Device Profile
deviceResources:
  - name: "TempFile"
    description: "温度数据文件"
    attributes:
      modbus:
        functionCode: 20              # 标准读文件记录
        fileName: "Temp"              # 文件名（自动映射到文件号1）
        
        # 触发配置（可选）
        triggerFunctionCode: 6
        triggerAddress: 100
        
        # 长度配置（二选一）
        fileLength: 256               # 固定长度（优先）
        # 或动态读取
        # lengthFunctionCode: 3
        # lengthAddress: 200
        # lengthQuantity: 2
    
    properties:
      valueType: "Binary"
      readWrite: "R"
```

### 3.2. Client 端配置（功能码 203）

```yaml
deviceResources:
  - name: "ConfigFile"
    description: "配置参数文件"
    attributes:
      modbus:
        functionCode: 203             # 自定义读文件
        registerAddress: 1000         # 寄存器地址
        quantity: 100                 # 读取数量（字）
        
        # 可选配置
        triggerFunctionCode: 6
        triggerAddress: 100
        lengthFunctionCode: 3
        lengthAddress: 200
    
    properties:
      valueType: "Binary"
      readWrite: "R"
```

### 3.3. 文件映射配置（file-mapping.json）

```json
[
  {
    "fileName": "Temp",
    "fileNumber": 1,
    "recordNumber": 0,
    "description": "温度数据文件，256字节"
  },
  {
    "fileName": "Status",
    "fileNumber": 2,
    "recordNumber": 0,
    "description": "设备状态文件，128字节"
  },
  {
    "fileName": "Config",
    "fileNumber": 3,
    "recordNumber": 0,
    "description": "配置参数文件，512字节"
  }
]
```

---

## 4. 测试用例

### 4.1. 功能码 20 测试

```bash
# 1. 读取文件（使用固定长度）
curl -X GET http://localhost:59882/api/v3/device/name/ModbusDevice/TempFile

# 预期：返回 256 字节的二进制数据（Base64编码）

# 2. 读取文件（使用动态长度）
# 配置 lengthFunctionCode=3, lengthAddress=200
# 设备返回长度 = 128 字节
curl -X GET http://localhost:59882/api/v3/device/name/ModbusDevice/StatusFile

# 预期：返回 128 字节的数据
```

### 4.2. 功能码 21 测试

```bash
# 写入文件
curl -X PUT http://localhost:59882/api/v3/device/name/ModbusDevice/ConfigFile \
  -H "Content-Type: application/json" \
  -d '{
    "ConfigFile": "SGVsbG8gV29ybGQ="  // Base64("Hello World")
  }'

# 预期：写入成功，设备返回回显数据
```

### 4.3. 功能码 203/204 测试

```bash
# 1. 读取文件（基于地址）
curl -X GET http://localhost:59882/api/v3/device/name/ModbusDevice/ConfigFile

# 2. 写入文件（基于地址）
curl -X PUT http://localhost:59882/api/v3/device/name/ModbusDevice/ConfigFile \
  -H "Content-Type: application/json" \
  -d '{
    "ConfigFile": "..."
  }'
```

---

## 5. 异常码说明

| 异常码 | 名称 | 说明 |
|--------|------|------|
| 0x01 | 非法功能 | 不支持该功能码 |
| 0x02 | 非法数据地址 | 文件号或记录号不存在 |
| 0x03 | 非法数据值 | 参考类型错误、长度错误等 |
| 0x04 | 从站设备故障 | 设备内部错误 |
| 0x08 | 内存奇偶性错误 | 数据校验错误 |

---

## 6. 性能优化建议

### 6.1. Client 端
1. **缓存文件映射**：避免每次读取映射文件
2. **连接复用**：保持 TCP 连接不关闭
3. **批量读取**：一次读取完整文件，避免分块
4. **超时控制**：合理设置读取超时（建议 3-5 秒）

### 6.2. Server 端
1. **内存缓存**：将常用文件缓存到内存
2. **并发控制**：使用读写锁保护共享数据
3. **数据压缩**：对大文件使用压缩（如 gzip）
4. **持久化**：定期将文件数据持久化到磁盘

---

## 7. 总结

### 7.1. 功能码对比

| 特性 | 功能码 20/21 | 功能码 203/204 |
|------|-------------|---------------|
| 协议 | ✅ 标准 Modbus | ⚠️ 厂商自定义 |
| 访问方式 | 文件号 + 记录号 | 寄存器地址 |
| 配置复杂度 | 中等（需映射） | 低（直接地址） |
| 灵活性 | 高（支持多子请求） | 低（单次请求） |
| 设备支持 | 部分设备 | 较少设备 |

### 7.2. 选型建议

**使用功能码 20/21 的场景**：
- 设备支持标准 Modbus 文件记录功能
- 需要操作多个独立文件
- 文件结构化存储（记录 + 字段）

**使用功能码 203/204 的场景**：
- 设备仅支持自定义文件功能
- 简单的连续数据块读写
- 设备厂商推荐使用地址方式

---
