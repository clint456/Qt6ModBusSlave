# Lambda表达式

```cpp
[capture](parameters) -> return_type { body }

```

是 C++ **Lambda 表达式**的标准形式。其中 **`capture`（捕获列表）** 决定了 Lambda 能访问哪些**外部作用域中的变量**。

---

## 一、`capture` 的常见写法和含义

### 1. **`[]` —— 不捕获任何外部变量**

```cpp
auto f = []() { cout << "Hello"; };

```

- 只能使用局部变量或全局变量。
- 无法访问函数内的局部变量或类成员。

---

### 2. **`[this]` —— 按值捕获当前对象的 `this` 指针**

```cpp
connect(..., [this]() { emit done(); });

```

- 可以访问当前对象的所有成员（函数、变量、信号等）。
- **注意**：只是复制了 `this` 指针，不是深拷贝对象。

> ⚠️ Qt 中配合 connect(sender, signal, this, lambda) 使用才安全！
> 

---

### 3. **`[&]` —— 以引用方式捕获所有**（自动推导）

```cpp
int x = 10;
auto f = [&]() { x = 20; }; // 修改外部 x
f();
cout << x; // 输出 20

```

- 捕获**当前作用域中所有被用到的变量**（C++14 起），或全部变量（C++11）。
- **危险**：如果 Lambda 在变量销毁后被调用，会访问悬空引用（crash）！

---

### 4. **`[=]` —— 以值方式捕获所有**（自动推导）

```cpp
int x = 10;
auto f = [=]() { cout << x; }; // x 被复制，值为 10

```

- 所有外部变量按值拷贝进 Lambda。
- 安全，但注意：
    - 对象大时有拷贝开销；
    - 修改副本不影响外部变量。

---

### 5. **显式捕获单个变量**

| 写法 | 含义 |
| --- | --- |
| `[x]` | 按值捕获变量 `x` |
| `[&x]` | 按引用捕获变量 `x` |
| `[x, &y]` | `x` 按值，`y` 按引用 |

```cpp
int a = 1, b = 2;
auto f = [a, &b]() {
    cout << a;   // 1（副本）
    b = 99;      // 修改外部 b
};
f();
cout << b; // 输出 99

```

---

### 6. **C++14 起：广义 Lambda 捕获**（初始化捕获）

可以**在捕获时创建新变量**，甚至移动对象：

```cpp
// 移动一个 unique_ptr 进 Lambda
std::unique_ptr<int> p = std::make_unique<int>(42);
auto f = [p = std::move(p)]() { 
//把外部 p 的资源“移动”到 Lambda 内部的一个同名（或新名）变量中。
    cout << *p;
};
// 此时外部 p 已为空
```

| 部分 | 含义 |
| --- | --- |
| 左边的 `p` | 是 Lambda 内部新创建的成员变量名（你可以改成别的名字，比如 `[my_p = std::move(p)]`） |
| 右边的 `std::move(p)` | 将外部作用域的 `p` 转为右值引用 |
| `=` | 表示用右边的值初始化 Lambda 内部的 `p` |

或者重命名：

```cpp
int value = 100;
auto f = [v = value * 2]() { cout << v; }; // v 是 200

```

---

## 🚫 二、Qt 信号槽中使用 Lambda 的注意事项

虽然 Lambda 很强大，但在 Qt 的 `connect` 中要特别小心：

### ✅ 安全写法（推荐）：

```cpp
connect(sender, &Signal, this, [this, x = someValue]() {
    // 可以用 this 和 x（按值捕获）
});

```

- 指定了 `this` 作为 context（第 3 个参数）→ 对象销毁时自动断开连接。
- 按值捕获外部变量（如 `x = someValue`）→ 避免悬空引用。

### ❌ 危险写法（避免）：

```cpp
int local = 10;
connect(sender, &Signal, [local]() { ... }); // 没有 context！

```

- 如果 `sender` 活得比 `local` 久，Lambda 被调用时 `local` 已销毁 → **未定义行为**！

---

## ✅ 三、总结：`capture` 常见选项

| 捕获方式 | 说明 | 是否常用（Qt 场景） |
| --- | --- | --- |
| `[]` | 不捕获 | 少（除非纯计算） |
| `[this]` | 捕获当前对象指针 | ✅ 非常常用 |
| `[=]` | 按值捕获所有 | ⚠️ 谨慎（可能拷贝大对象） |
| `[&]` | 按引用捕获所有 | ❌ 极少用（易 crash） |
| `[x]`, `[&x]` | 显式捕获 | ✅ 按需使用 |
| `[x = expr]` | 初始化捕获（C++14+） | ✅ 推荐用于安全传值 |

---

### 💡 最佳实践（Qt 开发）：

> 优先使用 [this] 或显式按值捕获（[val = x]），并始终将 this 作为 connect 的 context 参数，以确保内存安全。