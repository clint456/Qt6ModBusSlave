# C++ä¸­mutableå…³é”®å­—

åœ¨ C++ ä¸­ï¼Œå¦‚æœä½ å£°æ˜ä¸€ä¸ªæˆå‘˜å‡½æ•°ä¸º `const`ï¼š

```cpp
bool readCoil() const;
```

è¿™æ„å‘³ç€ï¼š
- **è¯¥å‡½æ•°æ‰¿è¯ºä¸ä¿®æ”¹å¯¹è±¡çš„ä»»ä½•æˆå‘˜å˜é‡**ï¼ˆé€»è¾‘ä¸Šâ€œåªè¯»â€ï¼‰ã€‚
- ç¼–è¯‘å™¨ä¼šå¼ºåˆ¶æ£€æŸ¥ï¼šå¦‚æœä½ åœ¨å‡½æ•°ä½“å†…è¯•å›¾ä¿®æ”¹æ™®é€šæˆå‘˜å˜é‡ï¼Œä¼šæŠ¥é”™ï¼

ä¾‹å¦‚ï¼š

```cpp
class Device {
    int value = 0;
public:
    void setValue(int v) { value = v; }        // OK
    int getValue() const { 
        value = 100;  // âŒ ç¼–è¯‘é”™è¯¯ï¼const å‡½æ•°ä¸èƒ½ä¿®æ”¹æˆå‘˜å˜é‡
        return value;
    }
};
```

---

## é‚£ä¹ˆ `mutable` æ˜¯å¹²ä»€ä¹ˆçš„ï¼Ÿ

`mutable` çš„ä½œç”¨æ˜¯ï¼š**â€œå³ä½¿åœ¨ const æˆå‘˜å‡½æ•°ä¸­ï¼Œä¹Ÿå…è®¸ä¿®æ”¹è¿™ä¸ªç‰¹å®šçš„æˆå‘˜å˜é‡â€**ã€‚

### ä¸ºä»€ä¹ˆéœ€è¦å®ƒï¼Ÿ

æœ‰äº›æˆå‘˜å˜é‡**å¹¶ä¸å±äºå¯¹è±¡çš„â€œé€»è¾‘çŠ¶æ€â€**ï¼Œå®ƒä»¬åªæ˜¯è¾…åŠ©å®ç°ï¼ˆæ¯”å¦‚ç¼“å­˜ã€æ—¥å¿—è®¡æ•°å™¨ã€äº’æ–¥é”ç­‰ï¼‰ã€‚  
è™½ç„¶æŠ€æœ¯ä¸Šå®ƒä»¬è¢«ä¿®æ”¹äº†ï¼Œä½†ä»ç”¨æˆ·è§’åº¦çœ‹ï¼Œ**å¯¹è±¡çš„â€œé€»è¾‘çŠ¶æ€â€å¹¶æ²¡æœ‰æ”¹å˜**ã€‚

> âœ… **å…³é”®æ€æƒ³**ï¼š`const` è¡¨ç¤ºâ€œé€»è¾‘ä¸å˜â€ï¼Œè€Œä¸æ˜¯â€œç‰©ç†å†…å­˜ä¸€å­—ä¸å˜â€ã€‚

---

## ğŸ§© ç»å…¸ä¾‹å­ï¼š`mutable` + äº’æ–¥é”ï¼ˆmutexï¼‰

å‡è®¾ä½ æœ‰ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„è®¾å¤‡ç±»ï¼Œæä¾›ä¸€ä¸ª `const` æ–¹æ³•è¯»å–çº¿åœˆçŠ¶æ€ï¼š

```cpp
#include <mutex>

class CoilDevice {
    bool coil_state = false;
    mutable std::mutex mtx;  // ğŸ‘ˆ æ³¨æ„ï¼šmutableï¼

public:
    // è¿™æ˜¯ä¸€ä¸ª const å‡½æ•°ï¼šè°ƒç”¨è€…è®¤ä¸ºå®ƒä¸ä¼šæ”¹å˜è®¾å¤‡çŠ¶æ€
    bool readCoil() const {
        std::lock_guard<std::mutex> lock(mtx); // ğŸ‘ˆ æ³¨æ„ï¼šåŠ é”ï¼ˆä¼šä¿®æ”¹ mtx å†…éƒ¨çŠ¶æ€ï¼‰
        return coil_state;                     // åªè¯»æ•°æ®
    }

    void setCoil(bool state) {
        std::lock_guard<std::mutex> lock(mtx);
        coil_state = state;
    }
};
```

### ä¸ºä»€ä¹ˆè¿™é‡Œ `mtx` å¿…é¡»æ˜¯ `mutable`ï¼Ÿ

- `std::mutex::lock()` ä¼šä¿®æ”¹ mutex å†…éƒ¨çš„çŠ¶æ€ï¼ˆæ¯”å¦‚è®¾ç½®â€œå·²é”å®šâ€æ ‡å¿—ï¼‰ã€‚
- ä½† `readCoil()` æ˜¯ `const` å‡½æ•° â†’ é»˜è®¤ä¸èƒ½ä¿®æ”¹ä»»ä½•æˆå‘˜ã€‚
- ç„¶è€Œï¼Œ**åŠ é”/è§£é”åªæ˜¯å®ç°çº¿ç¨‹å®‰å…¨çš„æ‰‹æ®µï¼Œå¹¶æ²¡æœ‰æ”¹å˜ `coil_state` è¿™ä¸ªâ€œé€»è¾‘çŠ¶æ€â€**ã€‚
- æ‰€ä»¥æˆ‘ä»¬æŠŠ `mtx` å£°æ˜ä¸º `mutable`ï¼Œå‘Šè¯‰ç¼–è¯‘å™¨ï¼šâ€œè¿™ä¸ªå˜é‡å¯ä»¥ä¾‹å¤–â€ã€‚

> ğŸ’¡ æ¢å¥è¯è¯´ï¼š**`mutable` ç”¨äºé‚£äº›â€œä¸å½±å“å¯¹è±¡é€»è¾‘å€¼â€çš„å†…éƒ¨å®ç°ç»†èŠ‚**ã€‚

---

## ğŸ§  å…¶ä»–å¸¸è§ç”¨é€”

1. **ç¼“å­˜ / æ‡’åŠ è½½**ï¼ˆLazy Evaluationï¼‰
   ```cpp
   class ExpensiveData {
       mutable std::optional<int> cache;  // ç¼“å­˜ç»“æœ
       mutable bool cache_valid = false;

   public:
       int compute() const {
           if (!cache_valid) {
               cache = heavyCalculation(); // ä¿®æ”¹ mutable æˆå‘˜
               cache_valid = true;
           }
           return *cache;
       }
   };
   ```

2. **è°ƒè¯•è®¡æ•°å™¨**
   ```cpp
   mutable int access_count = 0;

   int getValue() const {
       ++access_count; // è®°å½•è®¿é—®æ¬¡æ•°ï¼Œä½†ä¸æ”¹å˜â€œå€¼â€
       return value;
   }
   ```

---

## æ€»ç»“

| æ¦‚å¿µ | è¯´æ˜ |
|------|------|
| `const` æˆå‘˜å‡½æ•° | æ‰¿è¯ºä¸æ”¹å˜å¯¹è±¡çš„**é€»è¾‘çŠ¶æ€** |
| `mutable` æˆå‘˜å˜é‡ | æ ‡è®°ä¸ºâ€œå¯å˜çš„å®ç°ç»†èŠ‚â€ï¼Œ**å…è®¸åœ¨ const å‡½æ•°ä¸­ä¿®æ”¹** |
| å…¸å‹åœºæ™¯ | äº’æ–¥é”ã€ç¼“å­˜ã€æ—¥å¿—ã€æ€§èƒ½è®¡æ•°å™¨ç­‰ |
| è®¾è®¡å“²å­¦ | åŒºåˆ† **é€»è¾‘å¸¸é‡æ€§**ï¼ˆlogical constnessï¼‰å’Œ **ç‰©ç†å¸¸é‡æ€§**ï¼ˆbitwise constnessï¼‰ |

> ğŸŒŸ è®°ä½ï¼š`mutable` ä¸æ˜¯â€œç»•è¿‡ constâ€ï¼Œè€Œæ˜¯**æ­£ç¡®è¡¨è¾¾â€œé€»è¾‘ä¸å˜æ€§â€** çš„å·¥å…·ã€‚
