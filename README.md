# Qt6 Modbus 从站服务器

一个功能完整的 Modbus TCP/RTU 从站服务器，使用 Qt6 开发，支持图形界面操作。

## 功能特性

### 支持的通信模式
- **TCP 模式**: 标准 Modbus TCP 协议（默认端口 502）
- **RTU 模式**: Modbus RTU 串口通信（支持多种波特率）

### 支持的标准功能码

#### 读操作
| 功能码 | 名称 | 说明 |
|--------|------|------|
| 01 | 读线圈 | 读取线圈状态（0x00-0xFFFF） |
| 02 | 读离散输入 | 读取离散输入状态 |
| 03 | 读保持寄存器 | 读取保持寄存器数据 |
| 04 | 读输入寄存器 | 读取输入寄存器数据 |

#### 写操作
| 功能码 | 名称 | 说明 |
|--------|------|------|
| 05 | 写单个线圈 | 写入单个线圈状态 |
| 06 | 写单个寄存器 | 写入单个保持寄存器 |
| 15 | 写多个线圈 | 写入多个线圈状态 |
| 16 | 写多个寄存器 | 写入多个保持寄存器 |

### 文件寄存器功能码
| 功能码 | 名称 | 说明 |
|--------|------|------|
| 20 | 读文件记录 | 标准文件记录读取 |
| 21 | 写文件记录 | 标准文件记录写入 |
| 203 | 自定义读文件 | 基于地址的文件读取 |
| 204 | 自定义写文件 | 基于地址的文件写入 |

## 编译和运行

### 系统要求
- Qt 6.8 或更高版本
- CMake 3.16 或更高版本
- C++17 编译器

### 构建步骤

1. 使用 Qt Creator 打开项目
   - 打开 `CMakeLists.txt`
   - 选择 Qt 6.8+ kit
   - 配置项目

2. 或使用命令行构建：
```bash
mkdir build
cd build
cmake ..
cmake --build .
```

3. 运行程序：
```bash
./appQt6ModBusSlave
```

## 使用说明

### 启动服务器

#### TCP 模式
1. 在"TCP 端口"输入框中输入端口号（默认 502）
2. 点击"启动 TCP"按钮
3. 服务器状态将显示"运行中"

#### RTU 模式
1. 在"串口名称"输入框中输入串口（如 COM1, /dev/ttyUSB0）
2. 选择波特率（9600, 19200, 38400, 57600, 115200）
3. 点击"启动 RTU"按钮
4. 服务器状态将显示"运行中"

### 数据初始化

点击"初始化数据"按钮将：
- 初始化 100 个线圈（地址 0-99）
- 初始化 100 个离散输入（地址 0-99）
- 初始化 100 个保持寄存器（地址 0-99）
- 初始化 100 个输入寄存器（地址 0-99）
- 创建 2 个测试文件（文件号 1 和 2）
- 初始化地址存储区域（地址 1000-1199）

### 数据监控

#### 标准数据监控

1. 选择"标准数据"标签页
2. 选择数据类型（线圈、离散输入、保持寄存器、输入寄存器）
3. 输入起始地址
4. 输入数量
5. 点击"刷新"查看当前数据

#### 文件寄存器操作

1. 选择"文件寄存器"标签页
2. **标准文件记录**（功能码 20/21）：
   - 设置文件号（如 1）
   - 设置记录号（如 0）
   - 设置记录数（如 10）
   - 点击"读取文件"或"写入测试数据"
3. **地址文件**（功能码 203/204）：
   - 设置起始地址（如 1000）
   - 设置寄存器数（如 20）
   - 点击"读取地址文件"或"写入测试数据"

详细说明请参见 [FILE_REGISTER_UI.md](FILE_REGISTER_UI.md)

### 停止服务器

点击"停止服务器"按钮即可停止当前运行的服务器。

## 测试

### 使用 Modbus Poll 测试（Windows）

1. 下载并安装 Modbus Poll
2. 创建新连接：
   - 连接类型：Modbus TCP/IP 或 Modbus RTU
   - IP 地址：127.0.0.1（本地测试）
   - 端口：502
   - 从站地址：1

3. 测试读操作：
   - 功能码 03：读保持寄存器
   - 起始地址：0
   - 数量：10

4. 测试写操作：
   - 功能码 06：写单个寄存器
   - 地址：0
   - 值：1234

### 使用 pymodbus 测试（Python）

```python
from pymodbus.client import ModbusTcpClient

# 连接到服务器
client = ModbusTcpClient('127.0.0.1', port=502)
client.connect()

# 读取保持寄存器
result = client.read_holding_registers(0, 10, slave=1)
print(f"保持寄存器: {result.registers}")

# 写入保持寄存器
client.write_register(0, 1234, slave=1)

# 读取线圈
result = client.read_coils(0, 10, slave=1)
print(f"线圈状态: {result.bits}")

# 写入多个寄存器
client.write_registers(10, [100, 200, 300], slave=1)

client.close()
```

## 项目结构

```
Qt6ModBusSlave/
├── main.cpp                    # 应用入口
├── Main.qml                    # QML 用户界面
├── CMakeLists.txt              # CMake 配置文件
├── ModbusTypes.h               # Modbus 类型定义
├── ModbusDataStore.h/cpp       # 数据存储管理
├── ModbusFunctionHandler.h/cpp # 功能码处理器
├── FileStore.h/cpp             # 文件寄存器存储
├── ModbusServer.h/cpp          # Modbus 服务器核心
└── README.md                   # 本文档
```

## 核心类说明

### ModbusServer
- 主服务器类，管理 TCP/RTU 连接
- 处理客户端请求并路由到对应处理器
- 提供 QML 接口

### ModbusDataStore
- 存储线圈、离散输入、保持寄存器、输入寄存器
- 线程安全的读写操作
- 支持信号通知数据变化

### ModbusFunctionHandler
- 处理标准 Modbus 功能码（01-06, 15-16）
- 验证请求格式
- 构建响应或错误消息

### FileStore
- 实现标准文件记录功能（功能码 20/21）
- 支持文件号和记录号访问
- 最多支持 10000 条记录

### FileAddressStore
- 实现自定义文件功能（功能码 203/204）
- 基于寄存器地址访问
- 适用于连续数据块

## 技术特点

- **线程安全**: 使用 QReadWriteLock 保护共享数据
- **大端字节序**: 严格遵循 Modbus 协议规范
- **CRC 校验**: RTU 模式自动计算和验证 CRC
- **错误处理**: 完整的异常码支持
- **实时监控**: UI 界面实时显示服务器状态和数据

## 异常码说明

| 异常码 | 名称 | 说明 |
|--------|------|------|
| 0x01 | 非法功能 | 不支持该功能码 |
| 0x02 | 非法数据地址 | 地址超出范围 |
| 0x03 | 非法数据值 | 数据值不合法 |
| 0x04 | 从站设备故障 | 设备内部错误 |
| 0x08 | 内存奇偶性错误 | 数据校验错误 |

## 许可证

本项目仅供学习和测试使用。

## 贡献

欢迎提交问题和改进建议！
